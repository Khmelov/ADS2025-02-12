package by.it.group410902.bolshakova.lesson14;

import java.util.*;

public class PointsA {

    // внутренний класс для реализации структуры данных DSU (Disjoint Set Union)
    // также известной как Union-Find - для работы с непересекающимися множествами
    static class DSU {
        int[] parent; // массив для хранения родителя каждого элемента
        int[] rank;   // массив для хранения ранга (высоты) дерева каждого корня

        // конструктор DSU - инициализирует структуру для n элементов
        DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            // изначально каждый элемент является своим собственным родителем
            // и имеет ранг 0 (дерево из одного элемента)
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        // метод find находит корень элемента с применением эвристики сжатия пути
        // сжатие пути уменьшает глубину дерева, присваивая всем элементам на пути прямую ссылку на корень
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // рекурсивно находим корень и обновляем ссылку
            }
            return parent[x];
        }

        // метод union объединяет два множества объединения по рангу
        // объединение по рангу прикрепляет дерево с меньшим рангом к дереву с большим рангом
        void union(int x, int y) {
            int rootX = find(x); // находим корень первого элемента
            int rootY = find(y); // находим корень второго элемента

            // если корни разные - множества нужно объединить
            if (rootX != rootY) {
                if (rank[rootX] < rank[rootY]) {
                    // если ранг первого дерева меньше, прикрепляем его ко второму
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    // если ранг второго дерева меньше, прикрепляем его к первому
                    parent[rootY] = rootX;
                } else {
                    // если ранги равны, прикрепляем одно к другому и увеличиваем ранг
                    parent[rootY] = rootX;
                    rank[rootX]++; // ранг увеличивается только при равенстве
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // считываем максимальное допустимое расстояние D между точками
        // точки будут объединяться если расстояние между ними строго меньше D
        double maxDistance = scanner.nextDouble();
        // считываем количество точек N в трехмерном пространстве
        int n = scanner.nextInt();

        // создаем массив для хранения координат всех точек
        // каждая точка представлена массивом из трех double значений: [x, y, z]
        double[][] points = new double[n][3];
        for (int i = 0; i < n; i++) {
            points[i][0] = scanner.nextDouble(); // координата x i-й точки
            points[i][1] = scanner.nextDouble(); // координата y i-й точки
            points[i][2] = scanner.nextDouble(); // координата z i-й точки
        }

        scanner.close(); // закрываем сканер так как больше ввод не нужен

        // создаем экземпляр DSU для управления кластерами точек
        // изначально каждая точка находится в своем собственном кластере (множестве)
        DSU dsu = new DSU(n);

        // проверяем все возможные пары точек для определения, нужно ли их объединять
        // внешний цикл перебирает все точки от первой до предпоследней
        for (int i = 0; i < n; i++) {
            // внутренний цикл перебирает все точки после i-й, чтобы избежать дублирования пар
            for (int j = i + 1; j < n; j++) {
                // вычисляем разности координат по осям
                double dx = points[i][0] - points[j][0];
                double dy = points[i][1] - points[j][1];
                double dz = points[i][2] - points[j][2];

                // вычисляем квадрат евклидова расстояния между точками
                // используем квадрат расстояния чтобы избежать вычисления квадратного корня
                // это улучшает производительность и избегает проблем с точностью чисел с плавающей точкой
                double squaredDistance = dx*dx + dy*dy + dz*dz;

                // сравниваем квадрат расстояния с квадратом максимального допустимого расстояния
                // если squaredDistance < maxDistance * maxDistance, то и фактическое расстояние < maxDistance
                // это математически эквивалентно но более эффективно вычислительно
                if (squaredDistance < maxDistance * maxDistance) {
                    // если расстояние допустимо, объединяем кластеры содержащие точки i и j
                    dsu.union(i, j);
                }
            }
        }

        // после объединения всех близких точек подсчитываем размеры получившихся кластеров
        // используем HashMap для подсчета количества точек в каждом кластере
        Map<Integer, Integer> clusterSizes = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // находим корень (идентификатор кластера) для каждой точки
            int root = dsu.find(i);
            // увеличиваем счетчик размера этого кластера
            clusterSizes.put(root, clusterSizes.getOrDefault(root, 0) + 1);
        }

        // собираем размеры всех кластеров в список
        List<Integer> sizes = new ArrayList<>(clusterSizes.values());
        // сортируем размеры кластеров в порядке УБЫВАНИЯ
        // это требование тестовой системы - выводить размеры от наибольшего к наименьшему
        Collections.sort(sizes, Collections.reverseOrder());

        // выводим результат - размеры кластеров через пробел
        for (int i = 0; i < sizes.size(); i++) {
            if (i > 0) System.out.print(" "); // добавляем пробел между числами (кроме первого)
            System.out.print(sizes.get(i));
        }
    }
}