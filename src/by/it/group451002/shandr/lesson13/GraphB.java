package by.it.group451002.shandr.lesson13;


import java.util.*;

// считывается строка структуры орграфа
// Затем в консоль выводится фраза о наличии циклов.
// Возможные варианты yes и no.
public class GraphB {
    // Список смежности графа, где ключи — вершины, значения — списки соседей
    // Ключ: вершина графа (String)
    // Значение: список вершин, достижимых из данной вершины (List<String>)
    private final Map<String, List<String>> adjacencyList = new HashMap<>();

    // Флаг, указывающий на наличие цикла в графе
    // true - граф содержит хотя бы один цикл
    // false - граф ациклический
    private boolean hasCycle = false;

    // Метод возвращает, есть ли цикл в графе
    // Возвращает true если граф содержит цикл, false если граф ациклический
    public boolean hasCycle() { return hasCycle; }

    // Конструктор: создает граф из входной строки
    public GraphB(String input) {
        // Разделяем входную строку на отдельные ребра
        var edges = input.split(", ");

        // Обрабатываем каждое ребро из входной строки
        for (var edge : edges) {
            // Разделяем каждое ребро на начальную и конечную вершины
            var vertices = edge.split(" -> ");
            var from = vertices[0];  // Начальная вершина ребра (откуда исходит)
            var to = vertices[1];    // Конечная вершина ребра (куда ведет)

            // Добавляем ребро в список смежности
            adjacencyList.computeIfAbsent(from, _1_ -> new ArrayList<>()).add(to);
        }

        // После построения графа проверяем наличие циклов
        checkCycle();
    }

    // Метод проверки циклов в графе с использованием алгоритма обхода в глубину
    // Алгоритм использует два множества для отслеживания состояния вершин:
    // - marked: все вершины, которые были посещены хотя бы раз
    // - onStack: вершины, которые находятся в текущем пути обхода (текущий стек рекурсии)
    private void checkCycle() {
        var marked  = new HashSet<String>();  // Множество всех посещенных вершин
        var onStack = new HashSet<String>();  // Множество вершин в текущем пути DFS

        // Проверяем каждую вершину графа на наличие циклов
        // Необходимо проверять все вершины, так как граф может быть несвязным
        for (var vertex : adjacencyList.keySet())
            // Если вершина еще не посещена, запускаем алгоритм обхода в глубину от нее
            if (!marked.contains(vertex))
                checkCycle(vertex, marked, onStack);
    }

    // Рекурсивный метод для поиска циклов от текущей вершины с использованием алгоритма обхода в глубину
    // Алгоритм: если при обходе мы встречаем вершину, которая уже находится в текущем стеке (onStack),
    // это означает, что мы нашли цикл - вернулись к вершине, которая еще не завершила обработку
    private void checkCycle(String vertex, HashSet<String> marked, HashSet<String> onStack) {
        // Помечаем текущую вершину как посещенную
        marked.add(vertex);

        // Добавляем вершину в текущий стек обхода (текущий путь DFS)
        onStack.add(vertex);

        // Получаем список соседних вершин для текущей вершины
        var neighbors = adjacencyList.get(vertex);

        // Если у вершины есть соседи, обрабатываем их рекурсивно
        if (neighbors != null)
            for (var neighbor : neighbors) {
                // Если цикл уже был обнаружен в предыдущих вызовах, прерываем выполнение
                if (hasCycle)
                    return;

                // Если соседняя вершина еще не посещена, рекурсивно проверяем ее
                if (!marked.contains(neighbor))
                    checkCycle(neighbor, marked, onStack);
                    // Если соседняя вершина уже находится в текущем стеке обхода - обнаружен цикл
                else if (onStack.contains(neighbor))
                    hasCycle = true;  // Устанавливаем флаг наличия цикла
            }

        // При возврате из рекурсии убираем вершину из текущего стека обхода
        // Это означает, что мы завершили исследование всех путей из данной вершины
        onStack.remove(vertex);
    }


    // Главный метод main: считывает входные данные, создает граф и выводит результат
    // Программа ожидает одну строку входных данных с описанием графа
    // Выводит "yes" если граф содержит цикл, "no" если граф ациклический
    public static void main(String[] args) {
        var scanner = new Scanner(System.in);

        // Считываем строку с описанием графа из стандартного ввода
        var graph = new GraphB(scanner.nextLine());

        // Выводим результат проверки на наличие циклов
        // "yes" - граф содержит цикл, "no" - граф ациклический
        System.out.print(graph.hasCycle() ? "yes" : "no");
    }
}

