# Название 

Поиск подстроки с ошибками

# Теория

## Алгоритм Bitap (Baeza-Yates-Gonnet)

### Основная идея

Алгоритм использует биты для компактного представления состояния совпадения. Каждый бит соответствует одной позиции в шаблоне. Если бит установлен (равен 1), это означает, что мы можем достичь этой позиции в шаблоне после обработки текущего символа текста.

Вместо хранения полной таблицы DP размером `текст × шаблон × ошибки`, мы храним только одно число (битовую маску) для каждого уровня ошибок.

### Подготовка: таблица символов

Перед началом поиска создаём таблицу `charMask`, где для каждого уникального символа хранится маска его позиций в шаблоне.

Например, для шаблона "cat":
- charMask['c'] = 001 (символ 'c' находится на позиции 0)
- charMask['a'] = 010 (символ 'a' находится на позиции 1)
- charMask['t'] = 100 (символ 't' находится на позиции 2)

Если символ встречается несколько раз, его маска будет содержать несколько установленных битов.

### Процесс поиска

Для каждого символа текста мы обновляем массив `dp`, где `dp[e]` — это битовая маска состояния после обработки текущего символа с ровно e ошибками.

Начально: `dp[0] = 0` (никаких совпадений).

Для каждого символа текста производятся четыре типа переходов:

**1. Совпадение символа (без ошибки)**

Если текущий символ совпадает с ожидаемым в шаблоне:
- Сдвигаем текущее состояние влево на один бит (это означает продвижение на одну позицию вперёд в шаблоне)
- Добавляем 1 в младший бит (начинаем новый потенциальный матч с текущей позиции)
- Применяем маску символа через побитовое И, чтобы оставить только те позиции, где этот символ реально встречается

**2. Замена символа (ошибка)**

Если мы хотим считать текущий символ заменой:
- Выполняем то же смещение и добавление 1, как при совпадении
- Но помещаем результат не в `dp[e]`, а в `dp[e+1]` (тратим одну ошибку)

**3. Вставка символа в текст (ошибка)**

Если мы пропускаем текущий символ текста (считаем его вставкой):
- Сдвигаем состояние влево и добавляем 1
- Помещаем в `dp[e+1]` без применения маски символа

**4. Удаление символа из шаблона (ошибка)**

Если мы пропускаем символ в шаблоне:
- Просто копируем текущее состояние без сдвига в `dp[e+1]`

### Определение совпадения

После обработки каждого символа текста проверяем, установлен ли последний бит (бит номер m-1, где m — длина шаблона) в любом из `dp[e]` при e ≤ maxErrors.

Если да — мы нашли совпадение на текущей позиции текста (с e ошибками).

# Описание задачи

Дан текст и шаблон для поиска. Необходимо найти все позиции в тексте, где встречается шаблон с допуском на k ошибок.

Под ошибками понимаются:
- Замена — символ не совпадает с ожидаемым
- Вставка — лишний символ в тексте
- Удаление — пропущен символ в тексте

Для каждого найденного совпадения вывести позицию и найденную подстроку в одной строке.

## Входные данные

Одна строка, содержащая три параметра, разделённых пробелом:
`text pattern maxErrors`

- `text` — исходный текст (длина до 10^4, только буквы и цифры)
- `pattern` — шаблон (длина от 1 до 64, только буквы и цифры)
- `maxErrors` — максимально допустимое количество ошибок (0 ≤ maxErrors < len(pattern))

## Выходные данные

Если совпадений не найдено, вывести:
```
none
```

Если совпадения найдены, вывести в одну строку пары `позиция подстрока`, разделённые пробелом:
```
pos1 substr1 pos2 substr2 ...
```